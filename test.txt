//grid.js

const shuffleArray = require('../helpers/fisherYates');

class Grid {
  constructor(size, cellSize = 10) {
    this.size = size;
    this.cellSize = cellSize;
    this.obstacles = new Map();
    this.cells = Array.from({ length: Math.ceil(size / cellSize) }, () =>
      Array.from({ length: Math.ceil(size / cellSize) }, () => ({
        predators: [],
        preys: [],
      }))
    );
    this.grass = Array.from({ length: size }, () =>
      Array.from({ length: size }, () => false)
    );
    this.availablePositions = this.generateAvailablePositions();
  }

  generateObstacleKey(x, y) {
    return `${x},${y}`;
  }

  setPredatorsAndPreys(predators, preys) {
    this.predators = predators;
    this.preys = preys;

    predators.forEach((predator) => {
      const cellX = Math.floor(predator.x / this.cellSize);
      const cellY = Math.floor(predator.y / this.cellSize);
      this.cells[cellX][cellY].predators.push(predator);
    });

    preys.forEach((prey) => {
      const cellX = Math.floor(prey.x / this.cellSize);
      const cellY = Math.floor(prey.y / this.cellSize);
      this.cells[cellX][cellY].preys.push(prey);
    });
  }

  addObstacle(x, y) {
    this.obstacles.set(this.generateObstacleKey(x, y), true);
  }

  isObstacle(x, y) {
    return this.obstacles.get(this.generateObstacleKey(x, y)) || false;
  }

  isValidMove(x, y) {
    return !this.isObstacle(x, y);
  }

  generateAvailablePositions() {
    const positions = [];

    for (let x = 0; x < this.size; x++) {
      for (let y = 0; y < this.size; y++) {
        if (!this.isObstacle(x, y)) {
          positions.push({ x, y });
        }
      }
    }

    return shuffleArray(positions);
  }

  randomPosition() {
    let position;
    let isOccupied;

    while (true) {
      position = {
        x: Math.floor(Math.random() * this.size),
        y: Math.floor(Math.random() * this.size),
      };

      isOccupied =
        this.isObstacle(position.x, position.y) ||
        this.predators.some((p) => p.x === position.x && p.y === position.y) ||
        this.preys.some((p) => p.x === position.x && p.y === position.y);

      if (!isOccupied) {
        break;
      }
    }

    return position;
  }

  addGrass(x, y) {
    this.grass[x][y] = true;
  }

  removeGrass(x, y) {
    this.grass[x][y] = false;
    this.availablePositions.push({ x, y });
    shuffleArray(this.availablePositions);
  }

  isGrass(x, y) {
    return this.grass[x][y];
  }

  spawnGrass() {
    if (this.availablePositions.length === 0) {
      console.warn('No available positions left to spawn grass.');
      return;
    }

    const position = this.availablePositions.pop();
    this.addGrass(position.x, position.y);
  }

  isCollision(predatorX, predatorY) {
    const predatorCellX = Math.floor(predatorX / this.cellSize);
    const predatorCellY = Math.floor(predatorY / this.cellSize);

    for (let dx = -1; dx <= 1; dx++) {
      for (let dy = -1; dy <= 1; dy++) {
        const cellX = predatorCellX + dx;
        const cellY = predatorCellY + dy;

        if (
          cellX >= 0 &&
          cellY >= 0 &&
          cellX < this.cells.length &&
          cellY < this.cells[0].length
        ) {
          const cellPreys = this.cells[cellX][cellY].preys;

          for (let i = 0; i < cellPreys.length; i++) {
            if (predatorX === cellPreys[i].x && predatorY === cellPreys[i].y) {
              return true;
            }
          }
        }
      }
    }

    return false;
  }

  getVisibleObstacles(agent) {
    const visibleObstacles = [];

    for (const [key, value] of this.obstacles.entries()) {
      if (value) {
        const [x, y] = key.split(',').map(Number);
        if (agent.canSee({ x, y })) {
          visibleObstacles.push({ x, y });
        }
      }
    }

    return visibleObstacles;
  }

  placePredators(predators) {
    predators.forEach((predator) => {
      const newPos = this.randomPosition();
      predator.setPosition(newPos.x, newPos.y);

      const cellX = Math.floor(newPos.x / this.cellSize);
      const cellY = Math.floor(newPos.y / this.cellSize);
      this.cells[cellX][cellY].predators.push(predator);
    });
  }

  placePreys(preys) {
    preys.forEach((prey) => {
      const newPos = this.randomPosition();
      prey.setPosition(newPos.x, newPos.y);

      const cellX = Math.floor(newPos.x / this.cellSize);
      const cellY = Math.floor(newPos.y / this.cellSize);
      this.cells[cellX][cellY].preys.push(prey);
    });
  }

  printGrid() {
    this.grid.forEach((row) => console.log(row.join(' | ')));
  }
}

module.exports = Grid;

---

//simulation.js

const Predator = require('../agents/predator');
const Prey = require('../agents/prey');
const Grid = require('../environment/grid');
const config = require('./config');

const MAX_STEPS_PER_EPISODE = config.MAX_STEPS_PER_EPISODE;
const nrOfGrassObjects = config.nrOfGrassObjects;

// Create a new grid
const grid = new Grid(config.gridSize);

let predatorTotalReward = 0;
let preyTotalReward = 0;
let stepCount = 0;
let episodeCount = 0;

let collisionRewardPredator = config.collisionRewardPredator;
let collisionRewardPrey = config.collisionRewardPrey;

const nrOfObstacles = config.nrOfObstacles;

const predators = [];
const preys = [];

for (let i = 0; i < config.nrOfPredators; i++) {
  predators.push(new Predator(null, null, grid, preys));
  preys.push(new Prey(null, null, grid, predators));
}

// Rely on placePredators and placePreys methods to set positions
grid.setPredatorsAndPreys(predators, preys);
grid.placePredators(predators);
grid.placePreys(preys);

function resetPositions() {
  console.log(` Resetting positions...`);
  predatorTotalReward = 0;
  preyTotalReward = 0;
  stepCount = 0;

  grid.placePredators(predators);
  grid.placePreys(preys);
}

for (let i = 0; i < nrOfObstacles; i++) {
  let obstaclePos = grid.randomPosition();
  while (
    predators.some((p) => p.x === obstaclePos.x && p.y === obstaclePos.y) ||
    preys.some((p) => p.x === obstaclePos.x && p.y === obstaclePos.y)
  ) {
    obstaclePos = grid.randomPosition();
  }
  grid.addObstacle(obstaclePos.x, obstaclePos.y);
}

for (let i = 0; i < nrOfGrassObjects; i++) {
  grid.spawnGrass();
}

async function runStep(predator, prey) {
  const predatorAction = predator.chooseAction(predator.getState());
  predator.move(predatorAction);

  const preyAction = prey.chooseAction(prey.getState());
  prey.move(preyAction);

  const predatorVisibleObstacles = grid.getVisibleObstacles(predator);

  const predatorReward = predator.getReward(
    prey.getState(), // Call getState() after moving the agent
    predatorVisibleObstacles
  );

  const preyVisibleObstacles = grid.getVisibleObstacles(prey);

  const preyReward = prey.getReward(
    predator.getState(), // Call getState() after moving the agent
    preyVisibleObstacles
  );

  if (grid.isGrass(prey.x, prey.y)) {
    grid.removeGrass(prey.x, prey.y);
    setTimeout(() => grid.spawnGrass(), config.grassRespawnTime);
  }

  const isCaught = grid.isCollision(predator.x, predator.y);

  if (isCaught || stepCount >= MAX_STEPS_PER_EPISODE) {
    console.log(`Episode ${episodeCount} ended after ${stepCount} steps`);
    episodeCount++;

    predatorTotalReward += predatorReward;
    preyTotalReward += preyReward;

    if (isCaught) {
      predatorTotalReward += collisionRewardPredator;
      preyTotalReward += collisionRewardPrey;

      const newPredator = predator.spawn();
      predators.push(newPredator);

      const preyIndex = preys.indexOf(prey);
      if (preyIndex !== -1) {
        console.log(`Prey ${prey.id} was caught by predator ${predator.id} `);
        preys.splice(preyIndex, 1);
      }
      stepCount++;
      predator.lastCatchStep = stepCount;
    }

    resetPositions();
  } else {
    predatorTotalReward += predatorReward;
    preyTotalReward += preyReward;
  }

  // Check for reproduction and starvation of predators
  predators.forEach((predator, index) => {
    if (
      stepCount - predator.lastCatchStep >=
      config.predatorStarvationThreshold
    ) {
      // Remove the starving predator from the predators array
      console.log(
        `Predator ${predator.id} starved to death, it last caught a prey at step ${predator.lastCatchStep}`
      );
      predators.splice(index, 1);
    } else if (
      stepCount - predator.lastCatchStep >=
      config.predatorReproductionThreshold
    ) {
      // Spawn a new predator
      const newPredator = predator.spawn();
      predators.push(newPredator);
    }
  });

  // Check for reproduction of preys
  preys.forEach((prey, index) => {
    if (stepCount >= config.preyReproductionThreshold) {
      // Spawn a new prey
      const newPrey = prey.spawn();
      preys.push(newPrey);
    }
  });

  predator.updateQTable(
    predator.getState(),
    predatorAction,
    predatorReward,
    predator.getState()
  );

  prey.updateQTable(prey.getState(), preyAction, preyReward, prey.getState());
}

function emitData(socket) {
  const obstaclePositions = [];
  grid.obstacles.forEach((v, k) => {
    if (v) {
      const [x, y] = k.split(',').map(Number);
      obstaclePositions.push({ x, y });
    }
  });

  socket.emit('data', {
    predators: predators.map(({ x, y }) => ({ x, y })),
    preys: preys.map(({ x, y }) => ({ x, y })),
    obstacles: obstaclePositions,
    visiblePreysForPredators: predators.map((predator) =>
      preys.map((prey) => predator.canSee(prey))
    ),
    visiblePredatorsForPreys: preys.map((prey) =>
      predators.map((predator) => prey.canSee(predator))
    ),
    grass: grid.grass
      .map((row, x) =>
        row.map((cell, y) => (cell ? { x, y } : null)).filter((cell) => cell)
      )
      .flat(),
  });
}

async function startSimulation(io, socket) {
  emitData(socket);

  while (true) {
    predators.forEach((predator) => {
      preys.forEach((prey) => {
        runStep(predator, prey);
      });
    });

    emitData(socket);

    // Wait for 2000 milliseconds before running the next iteration
    await new Promise((resolve) => setTimeout(resolve, 2000));
    stepCount++;
    console.log(`Step ${stepCount}`);
  }
}

module.exports = { startSimulation };

---

As you can see, we're generating the grass on the back-end, sending it to the front-end, and from there on we're doing nothing.

I want you to create the front-side part of the grass, the grass can be represented as a green square.