//agent.js
const bresenhamLine = require('../helpers/bresenhamLine');

class Agent {
  constructor(x, y, grid) {
    this.grid = grid;
    if (x !== undefined && y !== undefined) {
      this.setPosition(x, y);
    }
    this.qTable = {};
    this.stepCount = 0;
    this.fieldOfView = this.fieldOfView || 360;
  }

  setPosition(x, y) {
    const newX = x % this.grid.size;
    const newY = y % this.grid.size;

    if (this.grid.isValidMove(newX, newY)) {
      this.x = newX;
      this.y = newY;
    } else {
      // Find the nearest valid position
      const validPositions = this.getValidNeighborPositions();
      if (validPositions.length > 0) {
        const nearestValidPosition = validPositions.reduce((prev, curr) => {
          const prevDistance = this.calculateDistance(x, y, prev.x, prev.y);
          const currDistance = this.calculateDistance(x, y, curr.x, curr.y);
          return prevDistance < currDistance ? prev : curr;
        });

        this.x = nearestValidPosition.x;
        this.y = nearestValidPosition.y;
      } else {
        throw new Error('Invalid move', x, y);
      }
    }
  }

  getValidNeighborPositions() {
    const neighbors = [
      { x: (this.x - 1 + this.grid.size) % this.grid.size, y: this.y },
      { x: (this.x + 1) % this.grid.size, y: this.y },
      { x: this.x, y: (this.y - 1 + this.grid.size) % this.grid.size },
      { x: this.x, y: (this.y + 1) % this.grid.size },
      {
        x: (this.x - 1 + this.grid.size) % this.grid.size,
        y: (this.y - 1 + this.grid.size) % this.grid.size,
      },
      {
        x: (this.x + 1) % this.grid.size,
        y: (this.y - 1 + this.grid.size) % this.grid.size,
      },
      {
        x: (this.x - 1 + this.grid.size) % this.grid.size,
        y: (this.y + 1) % this.grid.size,
      },
      { x: (this.x + 1) % this.grid.size, y: (this.y + 1) % this.grid.size },
    ];

    return neighbors.filter((neighbor) =>
      this.grid.isValidMove(neighbor.x, neighbor.y)
    );
  }

  getActions() {
    return [
      'up',
      'down',
      'left',
      'right',
      'up-left',
      'up-right',
      'down-left',
      'down-right',
    ];
  }

  calculateDistance(x1, y1, x2, y2) {
    const dx = Math.abs(x1 - x2);
    const dy = Math.abs(y1 - y2);
    const wrappedDx = Math.min(dx, this.grid.size - dx);
    const wrappedDy = Math.min(dy, this.grid.size - dy);
    return Math.sqrt(Math.pow(wrappedDx, 2) + Math.pow(wrappedDy, 2));
  }

  move(action) {
    let newX = this.x;
    let newY = this.y;

    switch (action) {
      case 'up':
        newY = (this.y - 1 + this.grid.size) % this.grid.size;
        break;
      case 'down':
        newY = (this.y + 1) % this.grid.size;
        break;
      case 'left':
        newX = (this.x - 1 + this.grid.size) % this.grid.size;
        break;
      case 'right':
        newX = (this.x + 1) % this.grid.size;
        break;
      case 'up-left':
        newX = (this.x - 1 + this.grid.size) % this.grid.size;
        newY = (this.y - 1 + this.grid.size) % this.grid.size;
        break;
      case 'up-right':
        newX = (this.x + 1) % this.grid.size;
        newY = (this.y - 1 + this.grid.size) % this.grid.size;
        break;
      case 'down-left':
        newX = (this.x - 1 + this.grid.size) % this.grid.size;
        newY = (this.y + 1) % this.grid.size;
        break;
      case 'down-right':
        newX = (this.x + 1) % this.grid.size;
        newY = (this.y + 1) % this.grid.size;
        break;
    }

    if (this.grid.isValidMove(newX, newY)) {
      this.x = newX;
      this.y = newY;
    }
  }

  canSee(otherAgent) {
    const distance = this.calculateDistance(
      this.x,
      this.y,
      otherAgent.x,
      otherAgent.y
    );

    // Calculate the angle between agent and otherAgent
    const angle =
      Math.atan2(otherAgent.y - this.y, otherAgent.x - this.x) *
      (180 / Math.PI);

    // Normalize the angle to be between 0 and 360
    const normalizedAngle = (angle + 360) % 360;

    // Check if normalizedAngle is within the field of view
    const halfFOV = this.fieldOfView / 2;
    const lowerBound = (normalizedAngle - halfFOV + 360) % 360;
    const upperBound = (normalizedAngle + halfFOV) % 360;

    const isWithinFOV =
      (lowerBound < upperBound &&
        normalizedAngle >= lowerBound &&
        normalizedAngle <= upperBound) ||
      (lowerBound > upperBound &&
        (normalizedAngle >= lowerBound || normalizedAngle <= upperBound));

    if (distance > this.visionRange || !isWithinFOV) {
      return false;
    }

    const linePoints = bresenhamLine(
      this.x,
      this.y,
      otherAgent.x,
      otherAgent.y
    );

    // Check if there's a direct line of sight without any obstacles
    return !linePoints.some((point) => this.grid.isObstacle(point.x, point.y));
  }

  getState() {
    return { x: this.x, y: this.y };
  }

  stateToString(state) {
    return `${state.x},${state.y}`;
  }

  stateToObject(state) {
    return { x: state.x, y: state.y };
  }

  chooseAction(state, temp) {
    const stateObj = this.stateToObject(state);
    const actions = this.getActions();

    if (!this.qTable[stateObj.x]) {
      this.qTable[stateObj.x] = {};
    }

    if (!this.qTable[stateObj.x][stateObj.y]) {
      this.qTable[stateObj.x][stateObj.y] = {};
      actions.forEach((action) => {
        this.qTable[stateObj.x][stateObj.y][action] = 0;
      });
    }

    const actionProbabilities = this.calculateActionProbabilities(
      stateObj,
      actions,
      temp
    );
    const selectedAction = this.selectActionBasedOnProbabilities(
      actions,
      actionProbabilities
    );

    return selectedAction;
  }

  calculateActionProbabilities(stateObj, actions, temp, heuristics = []) {
    if (!this.qTable[stateObj.x]) {
      this.qTable[stateObj.x] = {};
    }
    if (!this.qTable[stateObj.x][stateObj.y]) {
      this.qTable[stateObj.x][stateObj.y] = {};
      actions.forEach((action) => {
        this.qTable[stateObj.x][stateObj.y][action] = 0;
      });
    }

    const maxQValue = Math.max(
      ...actions.map((action) => this.qTable[stateObj.x][stateObj.y][action])
    );

    const rawProbabilities = actions.map((action, index) => {
      const qValue = this.qTable[stateObj.x][stateObj.y][action] || 0;
      const heuristicValue = heuristics[index] || 0;

      const expValue = Math.min(
        (qValue + heuristicValue - maxQValue) / temp,
        700
      );

      return isNaN(expValue) ? 0.01 : Math.exp(expValue);
    });

    // Calculate the sum of raw probabilities
    const sumProbabilities = rawProbabilities.reduce((a, b) => a + b, 0);

    // Normalize the probabilities by dividing each probability by the sum of all probabilities
    const normalizedProbabilities = rawProbabilities.map((probability) => {
      return probability / sumProbabilities;
    });

    if (normalizedProbabilities.every((p) => isNaN(p) || p === 0)) {
      // If all probabilities are NaN or 0, force the first probability to a small value (like 0.01)
      normalizedProbabilities[0] = 0.01;
    }

    return normalizedProbabilities;
  }

  // chooseAction(state, temp) {

  //   const stateStr = this.stateToString(state);
  //   const actions = this.getActions();
  //   if (!this.qTable[stateStr]) {
  //     // Initialize the qTable for all possible actions with 0 values
  //     this.qTable[stateStr] = {};
  //     actions.forEach((action) => {
  //       this.qTable[stateStr][action] = 0;
  //     });
  //   }

  //   const actionProbabilities = this.calculateActionProbabilities(
  //     stateStr,
  //     actions,
  //     temp
  //   );
  //   const selectedAction = this.selectActionBasedOnProbabilities(
  //     actions,
  //     actionProbabilities
  //   );

  //   return selectedAction;
  // }

  // calculateActionProbabilities(stateStr, actions, temp, heuristics = []) {
  //   // Initialize the qTable for the state if not already initialized
  //   if (!this.qTable[stateStr]) {
  //     this.qTable[stateStr] = {};
  //     actions.forEach((action) => {
  //       this.qTable[stateStr][action] = 0;
  //     });
  //   }

  //   const maxQValue = Math.max(
  //     ...actions.map((action) => this.qTable[stateStr][action])
  //   );

  //   const rawProbabilities = actions.map((action, index) => {
  //     const qValue = this.qTable[stateStr][action] || 0;
  //     const heuristicValue = heuristics[index] || 0;

  //     const expValue = Math.min(
  //       (qValue + heuristicValue - maxQValue) / temp,
  //       700
  //     );

  //     // console.log(`qValue: ${qValue}`);
  //     // console.log(`heuristicValue: ${heuristicValue}`);
  //     // console.log(`maxQValue: ${maxQValue}`);
  //     // console.log(`temp: ${temp}`);

  //     return isNaN(expValue) ? 0.01 : Math.exp(expValue);
  //   });

  //   // Calculate the sum of raw probabilities
  //   const sumProbabilities = rawProbabilities.reduce((a, b) => a + b, 0);

  //   // Normalize the probabilities by dividing each probability by the sum of all probabilities
  //   const normalizedProbabilities = rawProbabilities.map((probability) => {
  //     return probability / sumProbabilities;
  //   });

  //   // console.log(
  //   //   `Agent [${this.constructor.name}] raw probabilities:]`,
  //   //   rawProbabilities
  //   // );
  //   // console.log(
  //   //   `Agent [${this.constructor.name}] normalized probabilities:]`,
  //   //   normalizedProbabilities
  //   // );
  //   // console.log(
  //   //   `Agent [${this.constructor.name}] action probabilities for state [${stateStr}]:`
  //   // );

  //   if (normalizedProbabilities.every((p) => isNaN(p) || p === 0)) {
  //     // If all probabilities are NaN or 0, force the first probability to a small value (like 0.01)
  //     normalizedProbabilities[0] = 0.01;
  //   }

  //   return normalizedProbabilities;
  // }

  selectActionBasedOnProbabilities(actions, probabilities) {
    const sumProbabilities = probabilities.reduce((a, b) => a + b, 0);
    const randomValue = Math.random() * sumProbabilities;

    let cumulativeProb = 0;
    for (let i = 0; i < probabilities.length; i++) {
      cumulativeProb += probabilities[i];
      if (randomValue < cumulativeProb) {
        return actions[i];
      }
    }
  }

  updateQTable(state, action, reward, nextState) {
    const stateObj = this.stateToObject(state);
    const nextStateObj = this.stateToObject(nextState);
    if (!this.qTable[stateObj.x]) {
      this.qTable[stateObj.x] = {};
    }
    if (!this.qTable[stateObj.x][stateObj.y]) {
      this.qTable[stateObj.x][stateObj.y] = {};
    }
    const oldQ = this.qTable[stateObj.x][stateObj.y][action] || 0;
    const nextMaxQ = Math.max(
      ...Object.values(this.qTable[nextStateObj.x][nextStateObj.y] || {})
    );
    const learningRate = 1 / (1 + this.stepCount / 1000);

    this.qTable[stateObj.x][stateObj.y][action] =
      oldQ + learningRate * (reward + 0.9 * nextMaxQ - oldQ);
    this.stepCount++;

    if (this.qTable[stateObj.x][stateObj.y][action] > 0) {
      console.log(
        `Agent [${
          this.constructor.name
        }] updated qTable for state [${JSON.stringify(stateObj)}] ` +
          ` and action [${action}] to ${
            this.qTable[stateObj.x][stateObj.y][action]
          }`
      );
    }
  }

  // updateQTable(state, action, reward, nextState) {
  //   const stateStr = this.stateToString(state);
  //   const nextStateStr = this.stateToString(nextState);
  //   if (!this.qTable[stateStr]) {
  //     this.qTable[stateStr] = {};
  //   }
  //   const oldQ = this.qTable[stateStr][action] || 0;
  //   const nextMaxQ = Math.max(
  //     ...Object.values(this.qTable[nextStateStr] || {})
  //   );
  //   const learningRate = 1 / (1 + this.stepCount / 1000);

  //   this.qTable[stateStr][action] =
  //     oldQ + learningRate * (reward + 0.9 * nextMaxQ - oldQ);
  //   this.stepCount++;

  //   if (this.qTable[stateStr][action] > 0) {
  //     console.log(
  //       `Agent [${this.constructor.name}] updated qTable for state [${stateStr}] ` +
  //         ` and action [${action}] to ${this.qTable[stateStr][action]}`
  //     );
  //   }
  // }
}

module.exports = Agent;

---

//predator.js

const Agent = require('./agent');
class Predator extends Agent {
  constructor(x, y, grid, preys) {
    super(x, y, grid);
    this.fieldOfView = 90;
    this.qTable = {};
    this.preys = preys;
    this.visionRange = 5;
    this.lastCatchStep = 0;
  }

  spawn() {
    console.log(`Predator was spawned!`);

    const newPredator = new Predator(null, null, this.grid, this.preys);
    this.grid.placePredators([newPredator]);
    return newPredator;
  }

  chooseAction(state) {
    const visiblePreys = this.preys.filter((prey) => this.canSee(prey));
    const visibleObstacles = this.grid.obstacles.filter((obstacle) =>
      this.canSee({ x: obstacle.x, y: obstacle.y })
    );

    const actions = this.getActions();

    // If no visible preys, choose a random action
    if (visiblePreys.length === 0) {
      const temp = Math.max(1.4 - this.stepCount / 10000, 0.1);
      return super.chooseAction(state, temp);
    }

    const closestPrey = visiblePreys.reduce((closest, current) => {
      const closestDistance = this.calculateDistance(
        this.x,
        this.y,
        closest.x,
        closest.y
      );

      const currentDistance = this.calculateDistance(
        this.x,
        this.y,
        current.x,
        current.y
      );
      return currentDistance < closestDistance ? current : closest;
    });

    // Calculate heuristic values for each action
    const heuristicValues = actions.map((action) => {
      const { x: newX, y: newY } = this.getNewPositionAfterAction(action);

      const distanceToPrey =
        this.calculateDistance(newX, newY, closestPrey.x, closestPrey.y) +
        0.001;

      const distanceToClosestObstacle =
        Math.min(
          ...visibleObstacles.map((obstacle) =>
            this.calculateDistance(newX, newY, obstacle.x, obstacle.y)
          )
        ) + 0.001;

      const preyHeuristicFactor = -0.1; // Adjust this value to change the prey heuristic scaling
      const obstacleHeuristicFactor = 0.1; // Adjust this value to change the obstacle heuristic scaling
      const minObstacleDistance = 1; // Adjust this value to set the minimum allowed distance to an obstacle

      const preyHeuristic = preyHeuristicFactor * distanceToPrey;
      const obstacleHeuristic =
        distanceToClosestObstacle < minObstacleDistance
          ? obstacleHeuristicFactor * distanceToClosestObstacle
          : 0;

      return preyHeuristic + obstacleHeuristic;
    });

    const stateStr = this.stateToString(state);
    const temp = Math.max(1.4 - this.stepCount / 10000, 0.1);

    const actionProbabilities = this.calculateActionProbabilities(
      stateStr,
      actions,
      temp,
      heuristicValues
    );

    const selectedAction = this.selectActionBasedOnProbabilities(
      actions,
      actionProbabilities
    );

    return selectedAction;
  }

  getNewPositionAfterAction(action) {
    let newX = this.x;
    let newY = this.y;

    switch (action) {
      case 'up':
        newY = (this.y - 1 + this.grid.size) % this.grid.size;
        break;
      case 'down':
        newY = (this.y + 1) % this.grid.size;
        break;
      case 'left':
        newX = (this.x - 1 + this.grid.size) % this.grid.size;
        break;
      case 'right':
        newX = (this.x + 1) % this.grid.size;
        break;
      case 'up-left':
        newX = (this.x - 1 + this.grid.size) % this.grid.size;
        newY = (this.y - 1 + this.grid.size) % this.grid.size;
        break;
      case 'up-right':
        newX = (this.x + 1) % this.grid.size;
        newY = (this.y - 1 + this.grid.size) % this.grid.size;
        break;
      case 'down-left':
        newX = (this.x - 1 + this.grid.size) % this.grid.size;
        newY = (this.y + 1) % this.grid.size;
        break;
      case 'down-right':
        newX = (this.x + 1) % this.grid.size;
        newY = (this.y + 1) % this.grid.size;
        break;
    }

    return { x: newX, y: newY };
  }

  // ...

  getReward(preyState, obstacleStates) {
    const dx = Math.abs(this.x - preyState.x);
    const dy = Math.abs(this.y - preyState.y);
    const wrappedDx = Math.min(dx, this.grid.size - dx);
    const wrappedDy = Math.min(dy, this.grid.size - dy);
    const distanceToPrey =
      Math.sqrt(Math.pow(wrappedDx, 2) + Math.pow(wrappedDy, 2)) + 0.001;

    // Calculate the distance to the closest obstacle
    const distanceToClosestObstacle = obstacleStates.length
      ? Math.min(
          ...obstacleStates.map((obstacle) =>
            this.calculateDistance(this.x, this.y, obstacle.x, obstacle.y)
          )
        ) + 0.001
      : Infinity;

    // console.log(`Predator distance to closest prey: ${distanceToPrey}`);

    const rewardFactor = 1.5; // Adjust this value to change the reward scaling
    const obstaclePenaltyFactor = 0.02; // Adjust this value to change the obstacle penalty scaling
    const minObstacleDistance = 1; // Adjust this value to set the minimum allowed distance to an obstacle

    const preyReward = Math.pow(distanceToPrey, rewardFactor);
    const obstaclePenalty =
      distanceToClosestObstacle < minObstacleDistance
        ? -Math.pow(distanceToClosestObstacle, obstaclePenaltyFactor)
        : 0;

    return preyReward + obstaclePenalty;
  }
}

module.exports = Predator;

---
const Agent = require('./agent');

// prey.js
class Prey extends Agent {
  constructor(x, y, grid, predators) {
    super(x, y, grid);
    this.fieldOfView = 270;
    this.qTable = {};
    this.predators = predators;
    this.visionRange = 3;
  }

  spawn() {
    console.log(`Prey was spawned!`);
    const newPrey = new Prey(null, null, this.grid, this.predators);
    this.grid.placePreys([newPrey]);
    return newPrey;
  }

  chooseAction(state) {
    const visiblePredators = this.predators.filter((predator) =>
      this.canSee(predator)
    );
    const visibleObstacles = this.grid.obstacles.filter((obstacle) =>
      this.canSee({ x: obstacle.x, y: obstacle.y })
    );

    const actions = this.getActions();

    // Calculate heuristic values for each action
    const heuristicValues = actions.map((action) => {
      const { x: newX, y: newY } = this.getNewPositionAfterAction(action);

      const distanceToClosestPredator =
        Math.min(
          ...visiblePredators.map((predator) =>
            this.calculateDistance(newX, newY, predator.x, predator.y)
          )
        ) + 0.001;
      const distanceToClosestObstacle =
        Math.min(
          ...visibleObstacles.map((obstacle) =>
            this.calculateDistance(newX, newY, obstacle.x, obstacle.y)
          )
        ) + 0.001;

      const predatorHeuristicFactor = 1.5; // Adjust this value to change the predator heuristic scaling
      const obstacleHeuristicFactor = -0.5; // Adjust this value to change the obstacle heuristic scaling
      const minObstacleDistance = 1; // Adjust this value to set the minimum allowed distance to an obstacle

      const predatorHeuristic =
        predatorHeuristicFactor * distanceToClosestPredator;
      const obstacleHeuristic =
        distanceToClosestObstacle < minObstacleDistance
          ? obstacleHeuristicFactor * distanceToClosestObstacle
          : 0;

      return predatorHeuristic + obstacleHeuristic;
    });

    const stateStr = this.stateToString(state);
    const temp = Math.max(1.4 - this.stepCount / 10000, 0.1);
    const actionProbabilities = this.calculateActionProbabilities(
      stateStr,
      actions,
      temp,
      heuristicValues
    );

    const selectedAction = this.selectActionBasedOnProbabilities(
      actions,
      actionProbabilities
    );

    return selectedAction;
  }

  getNewPositionAfterAction(action) {
    let newX = this.x;
    let newY = this.y;

    switch (action) {
      case 'up':
        newY = (this.y - 1 + this.grid.size) % this.grid.size;
        break;
      case 'down':
        newY = (this.y + 1) % this.grid.size;
        break;
      case 'left':
        newX = (this.x - 1 + this.grid.size) % this.grid.size;
        break;
      case 'right':
        newX = (this.x + 1) % this.grid.size;
        break;
      case 'up-left':
        newX = (this.x - 1 + this.grid.size) % this.grid.size;
        newY = (this.y - 1 + this.grid.size) % this.grid.size;
        break;
      case 'up-right':
        newX = (this.x + 1) % this.grid.size;
        newY = (this.y - 1 + this.grid.size) % this.grid.size;
        break;
      case 'down-left':
        newX = (this.x - 1 + this.grid.size) % this.grid.size;
        newY = (this.y + 1) % this.grid.size;
        break;
      case 'down-right':
        newX = (this.x + 1) % this.grid.size;
        newY = (this.y + 1) % this.grid.size;
        break;
    }

    return { x: newX, y: newY };
  }

  getReward(predatorState, obstacleStates) {
    const dx = Math.abs(this.x - predatorState.x);
    const dy = Math.abs(this.y - predatorState.y);
    const wrappedDx = Math.min(dx, this.grid.size - dx);
    const wrappedDy = Math.min(dy, this.grid.size - dy);
    const distanceToPredator =
      Math.sqrt(Math.pow(wrappedDx, 2) + Math.pow(wrappedDy, 2)) + 0.001;

    // Calculate the distance to the closest obstacle
    const distanceToClosestObstacle = obstacleStates.length
      ? Math.min(
          ...obstacleStates.map((obstacle) =>
            this.calculateDistance(this.x, this.y, obstacle.x, obstacle.y)
          )
        ) + 0.001
      : Infinity;

    // console.log(
    //   `Prey distance to closest obstacle: ${distanceToClosestObstacle}`
    // );

    const rewardFactor = 1.5; // Adjust this value to change the reward scaling
    const obstaclePenaltyFactor = 0.5; // Adjust this value to change the obstacle penalty scaling
    const minObstacleDistance = 1; // Adjust this value to set the minimum allowed distance to an obstacle

    const predatorReward = Math.pow(distanceToPredator, rewardFactor);
    const obstaclePenalty =
      distanceToClosestObstacle < minObstacleDistance
        ? -Math.pow(distanceToClosestObstacle, obstaclePenaltyFactor)
        : 0;

    return predatorReward + obstaclePenalty;
  }
}

module.exports = Prey;

----

class Grid {
  constructor(size) {
    this.size = size;
    this.obstacles = Array.from({ length: size }, () =>
      Array.from({ length: size }, () => false)
    );
  }

  setPredatorsAndPreys(predators, preys) {
    this.predators = predators;
    this.preys = preys;
  }

  addObstacle(x, y) {
    this.obstacles[x][y] = true;
  }

  isObstacle(x, y) {
    return this.obstacles[x][y];
  }

  isValidMove(x, y) {
    return !this.isObstacle(x, y);
  }

  randomPosition() {
    let position;
    let isOccupied;

    while (true) {
      position = {
        x: Math.floor(Math.random() * this.size),
        y: Math.floor(Math.random() * this.size),
      };

      isOccupied =
        this.isObstacle(position.x, position.y) ||
        this.predators.some((p) => p.x === position.x && p.y === position.y) ||
        this.preys.some((p) => p.x === position.x && p.y === position.y);

      if (!isOccupied) {
        break;
      }
    }

    return position;
  }

  isCollision(predatorX, predatorY, preyX, preyY) {
    return predatorX === preyX && predatorY === preyY;
  }

  placePredators(predators) {
    predators.forEach((predator) => {
      const newPos = this.randomPosition();
      predator.setPosition(newPos.x, newPos.y);
    });
  }

  placePreys(preys) {
    preys.forEach((prey) => {
      const newPos = this.randomPosition();
      prey.setPosition(newPos.x, newPos.y);
    });
  }

  printGrid() {
    this.grid.forEach((row) => console.log(row.join(' | ')));
  }
}

module.exports = Grid;

---

//simulation.js

const Predator = require('../agents/predator');
const Prey = require('../agents/prey');
const Grid = require('../environment/grid');
const config = require('./config');

const MAX_STEPS_PER_EPISODE = config.MAX_STEPS_PER_EPISODE;

// Create a new grid
const grid = new Grid(config.gridSize);

let predatorTotalReward = 0;
let preyTotalReward = 0;
let stepCount = 0;
let episodeCount = 0;

let collisionRewardPredator = config.collisionRewardPredator;
let collisionRewardPrey = config.collisionRewardPrey;

const nrOfObstacles = config.nrOfObstacles;

const predators = [];
const preys = [];

for (let i = 0; i < config.nrOfPredators; i++) {
  predators.push(new Predator(null, null, grid, preys));
  preys.push(new Prey(null, null, grid, predators));
}

// Rely on placePredators and placePreys methods to set positions
grid.setPredatorsAndPreys(predators, preys);
grid.placePredators(predators);
grid.placePreys(preys);

function resetPositions() {
  predatorTotalReward = 0;
  preyTotalReward = 0;
  stepCount = 0;

  grid.placePredators(predators);
  grid.placePreys(preys);

  preys.forEach((prey) => {
    if (prey.stepCount >= config.preySurvivalThreshold) {
      const newPrey = prey.spawn();
      preys.push(newPrey);
    }
  });
}

for (let i = 0; i < nrOfObstacles; i++) {
  let obstaclePos = grid.randomPosition();
  while (
    predators.some((p) => p.x === obstaclePos.x && p.y === obstaclePos.y) ||
    preys.some((p) => p.x === obstaclePos.x && p.y === obstaclePos.y)
  ) {
    obstaclePos = grid.randomPosition();
  }
  grid.addObstacle(obstaclePos.x, obstaclePos.y);
}

async function runStep(predator, prey) {
  const predatorAction = predator.chooseAction(predator.getState());
  predator.move(predatorAction);

  const preyAction = prey.chooseAction(prey.getState());
  prey.move(preyAction);

  const predatorVisibleObstacles = grid.obstacles.filter((obstacle) => {
    predator.canSee({ x: obstacle.x, y: obstacle.y });
  });

  const predatorReward = predator.getReward(
    prey.getState(),
    predatorVisibleObstacles
  );

  const preyVisibleObstacles = grid.obstacles.filter((obstacle) => {
    prey.canSee({ x: obstacle.x, y: obstacle.y });
  });

  const preyReward = prey.getReward(predator.getState(), preyVisibleObstacles);

  const isCaught = grid.isCollision(predator.x, predator.y, prey.x, prey.y);

  if (isCaught || stepCount >= MAX_STEPS_PER_EPISODE) {
    episodeCount++;

    predatorTotalReward += predatorReward;
    preyTotalReward += preyReward;

    if (isCaught) {
      predatorTotalReward += collisionRewardPredator;
      preyTotalReward += collisionRewardPrey;

      const newPredator = predator.spawn();
      predators.push(newPredator);

      const preyIndex = preys.indexOf(prey);
      if (preyIndex !== -1) {
        preys.splice(preyIndex, 1);
      }
      stepCount++;
      predator.lastCatchStep = stepCount;
    }

    resetPositions();
  } else {
    predatorTotalReward += predatorReward;
    preyTotalReward += preyReward;
  }

  if (
    stepCount - predator.lastCatchStep >=
    config.predatorStarvationThreshold
  ) {
    // Remove the starving predator from the predators array
    const predatorIndex = predators.indexOf(predator);
    if (predatorIndex !== -1) {
      predators.splice(predatorIndex, 1);
    }
  }

  predator.updateQTable(
    predator.getState(),
    predatorAction,
    predatorReward,
    predator.getState()
  );

  prey.updateQTable(prey.getState(), preyAction, preyReward, prey.getState());
}

async function startSimulation(io, socket) {
  socket.emit('data', {
    predators: predators.map(({ x, y }) => ({ x, y })),
    preys: preys.map(({ x, y }) => ({ x, y })),
    obstacles: grid.obstacles,
    visiblePreysForPredators: predators.map((predator) =>
      preys.map((prey) => predator.canSee(prey))
    ),
    visiblePredatorsForPreys: preys.map((prey) =>
      predators.map((predator) => prey.canSee(predator))
    ),
  });

  while (true) {
    predators.forEach((predator) => {
      preys.forEach((prey) => {
        runStep(predator, prey);
      });
    });

    socket.emit('data', {
      predators: predators.map(({ x, y }) => ({ x, y })),
      preys: preys.map(({ x, y }) => ({ x, y })),
      obstacles: grid.obstacles,
      visiblePreysForPredators: predators.map((predator) =>
        preys.map((prey) => predator.canSee(prey))
      ),
      visiblePredatorsForPreys: preys.map((prey) =>
        predators.map((predator) => prey.canSee(predator))
      ),
    });

    // Wait for 2000 milliseconds before running the next iteration
    await new Promise((resolve) => setTimeout(resolve, 2000));
    stepCount++;
  }
}

module.exports = { startSimulation };

---

//config.js

const config = {
  MAX_STEPS_PER_EPISODE: 1000,
  collisionRewardPredator: 100,
  collisionRewardPrey: -100,
  nrOfObstacles: 25,
  nrOfPredators: 5,
  nrOfPreys: 5,
  gridSize: 100,
  preySurvivalThreshold: 50,
  predatorStarvationThreshold: 50,
};

module.exports = config;
